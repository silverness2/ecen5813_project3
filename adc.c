/*******************************************************************************
 *
 * Copyright (C) 2019 by Shilpi Gupta
 *
 ******************************************************************************/

/*
 * @file    adc.c
 * @brief   Library definitions for ADC on the FRDM KL25Z MCU.
 * @version Project 3
 * @date    May 1, 2019
 */

/*
NOTES:
Two types of I/O ports in the microcontroller:
- General Purpose I/O (GPIO): Used for interfacing with LEDs, switches, LCD,
  keypad, etc
- Special Purpose I/O: Have a designated function such as ADC, UART, Timers...

Two registers associated with each I/O port:
- Data register
- Direction register
*/

#include <stdlib.h>
#include <math.h>
#include "adc.h"
#include "MKL25Z4.h"
#include "fsl_debug_console.h"
#include "led.h"


// Define static vars.
uint32_t my_buffer[NUM_SAMPLES];
int32_t dma_done = 0;
int32_t buff_num = 0;
uint32_t curr_peak = 0;
uint32_t lut[16] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16364, 32768};


void adc_init()
{
    // Enable clock for PORT E.
    SIM->SCGC5 |= SIM_SCGC5_PORTE(1);

    // Enable clock for ADC0 module.
    SIM->SCGC6 |= SIM_SCGC6_ADC0(1);

    // Select func for PTE20 pin that corresponds to ADC. (Default = ADC0)
    // (PCR bits 10-8 = MUX, 000 => Pin disable ((analog)). 
    // (i.e. Make PTE20 the ADC0 pin) (000 = 0x00).
    PORTE->PCR[20] |= PORT_PCR_MUX(0);

    // Reset the ADC configuration register.
    ADC0->CFG1 = 0;

    // Set single-ended mode (other option is differential mode).
    // (0 => single-ended)
    ADC0->SC1[0] |= ADC_SC1_DIFF(0);

    // Set ADC bit resolution to 16-bit mode (mode can be 8, 10, 12, or 16).
    // (bits 3-2 = 0xC = MODE, 11 => 16-bit conversion when DIFF = 0)
    // (0x11 hex = 3 dec)
    ADC0->CFG1 |= ADC_CFG1_MODE(3);

    // Set speed of clock source to the ADC
    // (bits 1-0 = 0x3 = ADICLK (Input Clock Select), 00 => Bus clock)
    ADC0->CFG1 |= ADC_CFG1_ADICLK(0);

    // Set clock divide select (ADIV) via the ADC. (bits 6-5 = 0x061,
    // clock divided by 2^ADIV) (here, sys clock ~= 20MHz, 20MHz / 2^1 ~= 10 MHz)
    ADC0->CFG1 |= ADC_CFG1_ADIV(3);
}

void adc_dma_init()
{
    // Clear registers.
    ADC0->SC1[0] = 0;
    ADC0->SC2 = 0;
    
    // DMA is enabled and will assert the ADC DMA request during an ADC
    // conversion complete event noted when any of the SC1n[COCO] flags is
    // asserted. (DMAEN = DMA Enable)
    ADC0->SC2 |= ADC_SC2_DMAEN(1);

    // 0: Hardware average function disabled.
    // 1: Hardware average function enabled.
    ADC0->SC3 |= ADC_SC3_AVGE(1);

    // ADCO = Continuous Conversion Enable
    // 0: One conversion or one set of conversions if the hardware averag
    //    function is enabled, that is, AVGE=1, after initiating a conversion.
    // 1: Continuous conversions or sets of conversions if the hardware average
    //    function is enabled, that is, AVGE=1, after initiating a conversion.
    ADC0->SC3 |= ADC_SC3_ADCO(1);

    // Set the conversion to occur on channel 0.
    // (bits 4-0 = ADCH = ADC input channel) (channel 0 = 00000)
    ADC0->SC1[0] = ADC_SC1_ADCH(0);
}

void dma_init()
{
    // Initialize clock for DMA multiplexer.
    SIM->SCGC6 |= SIM_SCGC6_DMAMUX(1);
    
    // Initialize clock for DMA.
    SIM->SCGC7 |= SIM_SCGC7_DMA(1);
    
    // Disable DMA MUX channel temporarily.
    DMAMUX0->CHCFG[0] = 0x00;
    
    // Set source address for channel to be ADC data register.
    //(i.e location of the peripheral data register)
    DMA0->DMA[0].SAR = (uint32_t)&ADC0->R[0];
    
    // Set destination address as beginning of buffer.
    DMA0->DMA[0].DAR = (uint32_t)&my_buffer;
    
    // Number of bytes to be transferred in each service request of the channel.
    // The DMA controller stops after a specified number of transfers.
    DMA0->DMA[0].DSR_BCR |= DMA_DSR_BCR_BCR(BYTE_COUNT);
    
    // Set source data size to be 1, 2, or 4 bytes.
    // (i.e. Size of source bus cycle of the DMA controller.)
    // (bits 21-20 = Source size, 00 => 32 bit, 10 => 16 bit)
    DMA0->DMA[0].DCR |= DMA_DCR_SSIZE(0);
    
    // Set destination data size to be 1, 2, or 4 bytes.
    // (i.e. Size of destination bus cycle for the DMA controller.)
    // (bits 18-17 = Destination size, 00 => 32 bit, 10 => 16 bit)
    DMA0->DMA[0].DCR |= DMA_DCR_DSIZE(0);
    
    // Set source to have no address update after each transfer.
    // (SINC = Source Increment, 0 => No change to SAR after a successful
    // transfer)
    DMA0->DMA[0].DCR |= DMA_DCR_SINC(0);
    
    // Set destination with address increment.
    // Controls whether destination address increments after each transfer.
    // (DINC = Destination Increment, 1 => The DAR increments by 1,2,4
    // depending on size of transfer).
    DMA0->DMA[0].DCR |= DMA_DCR_DINC(1);

    // Enable interrupt (EINT) on completion of transfer.
    // Determines whether an interrupt is generated by completing a transfer or
    // by the occurrence of an error condition.
    // 0: No interrupt is generated.
    // 1: Interrupt signal is enabled.
    DMA0->DMA[0].DCR |= DMA_DCR_EINT(1);
    
    // Set DMA channel 0 to transfer samples from ADC to buffer.
    // (ENBL = 0x80 of DMAMUX_CHCFG (Channel Configuration) register)
     DMAMUX0->CHCFG[0] |= DMAMUX_CHCFG_ENBL(1);
    
    // Set DMA multiplexer to route DMA request from ADC to DMA channel 0.
    // (i.e. Set the source for this channel.)
    // Source module = ADC, Source number = 40, (bits 5-0 = SOURCE)
    DMAMUX0->CHCFG[0] |= DMAMUX_CHCFG_SOURCE(40);
    
    // For debugging...
    PRINTF("In init(), addr of ADC->R[0] is: %p\r\n", &ADC0->R[0]); // addr of adc data reg
    PRINTF("In init(), addr stored in DMA0->DMA[0].SAR is p: %p\r\n\r\n", DMA0->DMA[0].SAR); // addr stored in reg
    PRINTF("In init(), addr of buffer is: %p\r\n", &my_buffer); // addr of buffer reg
    PRINTF("In init(), addr stored in DMA[0]->DAR is: %p\r\n\r\n", DMA0->DMA[0].DAR); // addr stored in reg
    
    // Enable the interrupt for DMA0.
    NVIC_EnableIRQ(DMA0_IRQn);
    
    // Start the transfer.
    // 0: DMA inactive
    // 1: The DMA begins the transfer in accordance to the values in the TCDn.
    //    START is cleared automatically after one module clock and always
    //    reads as logic 0.
    DMA0->DMA[0].DCR |= DMA_DCR_START(1);
}

int adc_did_complete_convert()
{
    // Check the COCO (Conversion Complete) flag in the ADC0_SC1A (Status
    // Control) register. (bit 7 = 0x080) When this flag goes high, the
    // conversion from analog to digital is complete and the value in the
    // ADC0_R0 register can be read. (The COCO flag is cleared automatically
    // when the data from the ADCx_Rn register is read.)
    if (ADC0->SC1[0] & ADC_SC1_COCO(1))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

uint16_t adc_get_digital_output()
{
   // The lower 16 bits of ADC0_RA contain the unsigned int result.
   return (uint16_t)ADC0->R[0];
}

uint16_t adc_get_digital_output_blocking()
{
    while (!adc_did_complete_convert()) {}

    return adc_get_digital_output();
}

// Attribution:
// https://www.reddit.com/r/C_Programming/comments/5hczva/integer_in_c_and_how_to_print_its_binary/
void printBits(char *name, uint32_t num)
{
    unsigned int mask = 1 << ((sizeof(int) << 3) - 1);
    PRINTF("%s", name);
    while (mask) {
        PRINTF("%d", (num&mask ? 1 : 0));
        mask >>= 1;
    }
    PRINTF("\r\n");
}

// Peak level is a measurement of the highest sample value observed over an
// interval.
void compute_peak_level()
{
    // Get start and end buffer indices of buffer not being written to by DMA buffer.
    uint32_t start = 0, end = 0;
    
    if (buff_num == 1)
    {
        start = 0;
        end = NUM_SAMPLES/2;
    }
    else
    {
        start = NUM_SAMPLES/2;
        end = NUM_SAMPLES;
    }

    // Compute current peak based on each sample in buffer.
    // TODO: Is this accurate? Should first value be >= ?
    for (int i = start; i < end; i++)
    {
        if (abs(my_buffer[i]) > curr_peak) // increase when abs value is higher than current sample value.
        {
    	    curr_peak = my_buffer[i];
        }
        else // decrease using a first order decay to zero.
        {
            // peak[n] = decay_coeff * peak[n-1]
    	    curr_peak = (uint32_t)(DECAY_COEFF * (float)curr_peak);
        }
    }
}

float log_2(uint32_t value)
{
    return log((float)value) / log((float)2);
}

// TODO: Streamline!
void show_dbfs()
{
    // Digital output range = [0, 65536] (max digital value of ADC data reg is
    // 16 bits.
    // dbFS range: [-15, 0] -> 16 values
    // uint32_t lut[16] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048,
    //                     4096, 8192, 16364, 32768}

    // 2^x = lut_value
    // log2 digital_value ~= x

    // Get exp "start" range and validate.
    int32_t exp = 0;
    if (curr_peak >= 1)
    {
 	exp = (int32_t)(log_2(curr_peak));
    }
    if (exp > 15)
    {
    	exp = 15;
    }

    // Get exp "end" range and validate.
    int32_t end = exp + 1;
    if (end > 15)
    {
	end = exp;
    }

    // Convert exp to dbFS: (max + min) - num
    int32_t dbfs = 16 - exp;

    // Use exp as index into lut and show which range the ADC value falls
    // within based on the lut. Also show dbfs.
    if (curr_peak < 1)
    {
        PRINTF("exp is: %i, lut raw 16-bit range is: [%u, %u] => dbFS is: -%i\r\n", exp, 0, lut[0], dbfs);
    }
    else
    {
        PRINTF("exp is: %i, lut raw 16-bit range is: [%u, %u] => dbFS is: -%i\r\n", exp, lut[exp], lut[end], dbfs);
    }
}

void DMA0_IRQHandler(void)
{
    // DSR_BCR DONE flag:
    // Set when all DMA controller transactions complete as determined by transfer
    // count, or based on error conditions. When BCR reaches zero, DONE is set when
    // the final transfer completes successfully. DONE can also be used to abort a
    // transfer by resetting the status bits. When a transfer completes, software
    // must clear DONE before reprogramming the DMA.
    // 0: DMA transfer is not yet complete. Writing a 0 has no effect.
    // 1: DMA transfer completed. Writing a 1 to this bit clears all DMA status bits and should be used in an
    //    interrupt service routine to clear the DMA interrupt and error bits
    
    // Disable the interrupt for DMA0.
    NVIC_DisableIRQ(DMA0_IRQn);

    // For debugging...
    /*PRINTF("In IRQ() at start, addr of buffer is: %p\r\n", &my_buffer); // addr of buffer reg
    PRINTF("In IRQ() at start, addr stored in DMA[0]->DAR is: %p\r\n", DMA0->DMA[0].DAR); // addr stored in reg
    printBits("In IRQ() at start, DSR_BCR is: ", DMA0->DMA[0].DSR_BCR);*/

    if (DMA_DSR_BCR_DONE(1))
    {
	// Clear the DMA interrupt and error bits.
	DMA0->DMA[0].DSR_BCR |= DMA_DSR_BCR_DONE(1);

	// Reset BCR size.
	DMA0->DMA[0].DSR_BCR |= DMA_DSR_BCR_BCR(BYTE_COUNT);

	// Necessary?
	DMA0->DMA[0].SAR = (uint32_t)&ADC0->R[0];

	// Reset destination address.
        if (buff_num == 0)
	{
	    DMA0->DMA[0].DAR = (uint32_t)&my_buffer + BYTE_COUNT;
	    buff_num = 1;
	}
	else
	{
	    DMA0->DMA[0].DAR = (uint32_t)&my_buffer;
	    buff_num = 0;
	}

	// Start the transfer.
	DMA0->DMA[0].DCR |= DMA_DCR_START(1);

	dma_done = 1;

        // For debugging...
        /*("In IRQ() after resetting DAR, addr of buffer is: %p\r\n", &my_buffer); // addr of buffer reg
	PRINTF("In IRQ() after resetting DAR, addr stored in DMA[0]->DAR is: %p\r\n", DMA0->DMA[0].DAR); // addr stored in reg
	printBits("In IRQ() after resetting DAR, DSR_BCR is: ", DMA0->DMA[0].DSR_BCR); // output giving: 1000000000 => 512 bytes, 512/4 = 128 elements*/

	// Toggle a blue led. Adding a for-loop delay so we can see the flicker.
	for (int i = 0; i < 70000; i++) {}
        toggle_led_blue();
    }
}

